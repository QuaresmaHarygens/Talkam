from datetime import datetime, timedelta
from uuid import uuid4

from fastapi import APIRouter, Depends, HTTPException, status
from jose import jwt
from passlib.context import CryptContext
from sqlalchemy import select
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from ..config import Settings
from ..models.core import User
from ..schemas.auth import (
    AnonymousStartRequest,
    AnonymousStartResponse,
    AuthTokens,
    LoginRequest,
    RegisterRequest,
)
from .deps import get_db_session, get_settings_dep

router = APIRouter(prefix="/auth", tags=["auth"])
password_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def _hash_password(password: str) -> str:
    return password_context.hash(password)


def _create_tokens(user_id: str, roles: list[str], settings: Settings) -> AuthTokens:
    now = datetime.utcnow()
    access_payload = {"sub": user_id, "roles": roles, "exp": now + timedelta(minutes=settings.access_token_expire_minutes)}
    refresh_payload = {"sub": user_id, "roles": roles, "exp": now + timedelta(minutes=settings.refresh_token_expire_minutes)}
    return AuthTokens(
        access_token=jwt.encode(access_payload, settings.secret_key, algorithm="HS256"),
        refresh_token=jwt.encode(refresh_payload, settings.secret_key, algorithm="HS256"),
        expires_in=settings.access_token_expire_minutes * 60,
        roles=roles,
    )


@router.post("/register", response_model=AuthTokens, status_code=status.HTTP_201_CREATED)
async def register_user(
    body: RegisterRequest,
    session: AsyncSession = Depends(get_db_session),
    settings: Settings = Depends(get_settings_dep),
) -> AuthTokens:
    user = User(
        full_name=body.full_name,
        phone=body.phone,
        email=body.email,
        password_hash=_hash_password(body.password),
        language=body.language,
    )
    session.add(user)
    try:
        await session.commit()
    except IntegrityError as exc:
        await session.rollback()
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="User exists") from exc

    return _create_tokens(str(user.id), [user.role], settings)


@router.post("/login", response_model=AuthTokens)
async def login_user(
    body: LoginRequest,
    session: AsyncSession = Depends(get_db_session),
    settings: Settings = Depends(get_settings_dep),
) -> AuthTokens:
    result = await session.execute(select(User).where(User.phone == body.phone))
    user = result.scalar_one_or_none()
    if not user or not password_context.verify(body.password, user.password_hash):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")
    return _create_tokens(str(user.id), [user.role], settings)


@router.post("/anonymous-start", response_model=AnonymousStartResponse)
async def anonymous_start(
    body: AnonymousStartRequest,
    settings: Settings = Depends(get_settings_dep),
) -> AnonymousStartResponse:
    token_payload = {
        "sub": str(uuid4()),
        "type": "anon",
        "county": body.county,
        "capabilities": body.capabilities,
        "exp": datetime.utcnow() + timedelta(minutes=settings.access_token_expire_minutes),
    }
    token = jwt.encode(token_payload, settings.secret_key, algorithm="HS256")
    return AnonymousStartResponse(token=token, expires_in=settings.access_token_expire_minutes * 60)
