from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from ..models.core import Comment, Location, Report, ReportMedia, Verification
from ..schemas.common import Location as LocationSchema
from ..schemas.common import MediaRef, ReportSummary
from ..schemas.report import (
    CommentRequest,
    ReportCreateRequest,
    ReportResponse,
    SearchResponse,
    VerificationRequest,
)
from .deps import get_current_user, get_db_session

router = APIRouter(prefix="/reports", tags=["reports"])


def _to_location_schema(location: Location | None) -> LocationSchema:
    if not location:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Missing location")
    return LocationSchema(
        latitude=location.latitude,
        longitude=location.longitude,
        county=location.county,
        district=location.district,
        description=location.description,
    )


def _to_media_schema(media: list[ReportMedia]) -> list[MediaRef]:
    return [
        MediaRef(
            key=item.media_key,
            type=item.media_type,
            checksum=item.checksum,
            blur_faces=item.blurred,
            voice_masked=item.voice_masked,
        )
        for item in media
    ]


@router.post("/create", response_model=ReportResponse, status_code=status.HTTP_201_CREATED)
async def create_report(
    body: ReportCreateRequest,
    session: AsyncSession = Depends(get_db_session),
    user=Depends(get_current_user),
) -> ReportResponse:
    location = Location(
        latitude=body.location.latitude,
        longitude=body.location.longitude,
        county=body.location.county,
        district=body.location.district,
        description=body.location.description,
    )
    session.add(location)
    await session.flush()

    report = Report(
        user_id=user.id,
        location_id=location.id,
        category=body.category,
        severity=body.severity,
        summary=body.summary,
        details=body.details,
        anonymous=body.anonymous or False,
        witness_count=body.witness_count or 0,
    )
    session.add(report)
    await session.flush()

    for media in body.media:
        session.add(
            ReportMedia(
                report_id=report.id,
                media_key=media.key,
                media_type=media.type,
                checksum=media.checksum,
                blurred=media.blur_faces if media.blur_faces is not None else True,
                voice_masked=media.voice_masked if media.voice_masked is not None else False,
            )
        )

    await session.commit()
    await session.refresh(report, attribute_names=["media", "location"])

    return ReportResponse(
        id=report.id,
        status=report.status,
        created_at=report.created_at,
        summary=report.summary,
        details=report.details,
        category=report.category,
        severity=report.severity,
        location=_to_location_schema(report.location),
        verification_score=report.ai_severity_score,
        media=_to_media_schema(report.media),
        timeline=[],
    )


@router.get("/{report_id}", response_model=ReportResponse)
async def get_report(
    report_id: UUID,
    session: AsyncSession = Depends(get_db_session),
    user=Depends(get_current_user),
) -> ReportResponse:
    stmt = (
        select(Report)
        .where(Report.id == report_id)
        .options(selectinload(Report.location), selectinload(Report.media))
    )
    result = await session.execute(stmt)
    report = result.scalar_one_or_none()
    if not report:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Report not found")
    return ReportResponse(
        id=report.id,
        status=report.status,
        created_at=report.created_at,
        summary=report.summary,
        details=report.details,
        category=report.category,
        severity=report.severity,
        location=_to_location_schema(report.location),
        verification_score=report.ai_severity_score,
        media=_to_media_schema(report.media),
        timeline=[],
    )


@router.get("/search", response_model=SearchResponse)
async def search_reports(
    session: AsyncSession = Depends(get_db_session),
    county: str | None = Query(default=None),
    category: str | None = Query(default=None),
    status_filter: str | None = Query(default=None, alias="status"),
    text: str | None = Query(default=None),
    user=Depends(get_current_user),
) -> SearchResponse:
    stmt = select(Report).options(selectinload(Report.location))
    if county:
        stmt = stmt.join(Report.location).where(Location.county == county)
    if category:
        stmt = stmt.where(Report.category == category)
    if status_filter:
        stmt = stmt.where(Report.status == status_filter)
    if text:
        stmt = stmt.where(Report.summary.ilike(f"%{text}%"))

    result = await session.execute(stmt.order_by(Report.created_at.desc()).limit(50))
    reports = result.scalars().unique().all()
    summaries = [
        ReportSummary(
            id=r.id,
            summary=r.summary,
            category=r.category,
            county=r.location.county if r.location else None,
            severity=r.severity,
            status=r.status,
        )
        for r in reports
    ]
    return SearchResponse(results=summaries)


@router.post("/{report_id}/verify")
async def verify_report(
    report_id: UUID,
    body: VerificationRequest,
    session: AsyncSession = Depends(get_db_session),
    user=Depends(get_current_user),
) -> dict[str, str]:
    report = await session.get(Report, report_id)
    if not report:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Report not found")

    verification = Verification(report_id=report.id, user_id=user.id, action=body.action, notes=body.comment)
    session.add(verification)

    if body.action == "confirm":
        report.status = "verified"
    elif body.action == "reject":
        report.status = "rejected"
    else:
        report.status = "needs-info"

    await session.commit()
    return {"status": report.status}


@router.post("/{report_id}/comment", status_code=status.HTTP_201_CREATED)
async def comment_report(
    report_id: UUID,
    body: CommentRequest,
    session: AsyncSession = Depends(get_db_session),
    user=Depends(get_current_user),
) -> dict[str, str]:
    report = await session.get(Report, report_id)
    if not report:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Report not found")

    comment = Comment(
        report_id=report.id,
        user_id=user.id,
        visibility=body.visibility,
        body=body.body,
    )
    session.add(comment)
    await session.commit()
    return {"message": "Comment added", "comment_id": str(comment.id)}
